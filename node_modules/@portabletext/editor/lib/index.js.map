{"version":3,"file":"index.js","sources":["../src/internal-utils/compound-client-rect.ts","../src/internal-utils/drag-selection.ts","../src/internal-utils/event-position.ts","../src/internal-utils/selection.ts","../src/internal-utils/selection-elements.ts","../src/editor/components/DefaultObject.tsx","../src/editor/components/drop-indicator.tsx","../src/editor/components/Element.tsx","../src/editor/components/Leaf.tsx","../src/editor/plugins/createWithHotKeys.ts","../src/editor/withSyncRangeDecorations.ts","../src/editor/Editable.tsx","../src/editor-event-listener.tsx"],"sourcesContent":["export function getCompoundClientRect(nodes: Array<Node>): DOMRect {\n  if (nodes.length === 0) {\n    return new DOMRect(0, 0, 0, 0)\n  }\n\n  const elements = nodes.filter((node) => node instanceof Element)\n\n  const firstRect = elements.at(0)?.getBoundingClientRect()\n\n  if (!firstRect) {\n    return new DOMRect(0, 0, 0, 0)\n  }\n\n  let left = firstRect.left\n  let top = firstRect.top\n  let right = firstRect.right\n  let bottom = firstRect.bottom\n\n  for (let i = 1; i < elements.length; i++) {\n    const rect = elements[i].getBoundingClientRect()\n    left = Math.min(left, rect.left)\n    top = Math.min(top, rect.top)\n    right = Math.max(right, rect.right)\n    bottom = Math.max(bottom, rect.bottom)\n  }\n\n  return new DOMRect(left, top, right - left, bottom - top)\n}\n","import type {EditorSnapshot} from '..'\nimport * as selectors from '../selectors'\nimport * as utils from '../utils'\nimport type {EventPosition} from './event-position'\n\n/**\n * Given the current editor `snapshot` and an `eventSelection` representing\n * where the drag event origins from, this function calculates the selection\n * in the editor that should be dragged.\n */\nexport function getDragSelection({\n  eventSelection,\n  snapshot,\n}: {\n  eventSelection: EventPosition['selection']\n  snapshot: EditorSnapshot\n}) {\n  let dragSelection = eventSelection\n\n  const draggedInlineObject = selectors.getFocusInlineObject({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection,\n    },\n  })\n\n  if (draggedInlineObject) {\n    return dragSelection\n  }\n\n  const draggingCollapsedSelection = selectors.isSelectionCollapsed({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection,\n    },\n  })\n  const draggedTextBlock = selectors.getFocusTextBlock({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection,\n    },\n  })\n  const draggedSpan = selectors.getFocusSpan({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: eventSelection,\n    },\n  })\n\n  if (draggingCollapsedSelection && draggedTextBlock && draggedSpan) {\n    // Looks like we are dragging an empty span\n    // Let's drag the entire block instead\n    dragSelection = {\n      anchor: utils.getBlockStartPoint(draggedTextBlock),\n      focus: utils.getBlockEndPoint(draggedTextBlock),\n    }\n  }\n\n  const selectedBlocks = selectors.getSelectedBlocks(snapshot)\n\n  if (\n    snapshot.context.selection &&\n    selectors.isSelectionExpanded(snapshot) &&\n    selectedBlocks.length > 1\n  ) {\n    const selectionStartBlock = selectors.getSelectionStartBlock(snapshot)\n    const selectionEndBlock = selectors.getSelectionEndBlock(snapshot)\n\n    if (!selectionStartBlock || !selectionEndBlock) {\n      return dragSelection\n    }\n\n    const selectionStartPoint = utils.getBlockStartPoint(selectionStartBlock)\n    const selectionEndPoint = utils.getBlockEndPoint(selectionEndBlock)\n\n    const eventSelectionInsideBlocks = selectors.isOverlappingSelection(\n      eventSelection,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {anchor: selectionStartPoint, focus: selectionEndPoint},\n      },\n    })\n\n    if (eventSelectionInsideBlocks) {\n      dragSelection = {\n        anchor: selectionStartPoint,\n        focus: selectionEndPoint,\n      }\n    }\n  }\n\n  return dragSelection\n}\n","import {Editor, type BaseRange, type Node} from 'slate'\nimport {DOMEditor, isDOMNode} from 'slate-dom'\nimport type {EditorSchema, EditorSelection} from '..'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport * as utils from '../utils'\nimport {toPortableTextRange} from './ranges'\nimport {getFirstBlock, getLastBlock, getNodeBlock} from './slate-utils'\nimport {fromSlateValue} from './values'\n\nexport type EventPosition = {\n  block: 'start' | 'end'\n  /**\n   * Did the event origin from the editor DOM node itself or from a child node?\n   */\n  isEditor: boolean\n  selection: NonNullable<EditorSelection>\n}\nexport type EventPositionBlock = EventPosition['block']\n\nexport function getEventPosition({\n  schema,\n  slateEditor,\n  event,\n}: {\n  schema: EditorSchema\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}): EventPosition | undefined {\n  const node = getEventNode({slateEditor, event})\n\n  if (!node) {\n    return undefined\n  }\n\n  const block = getNodeBlock({\n    editor: slateEditor,\n    schema,\n    node,\n  })\n\n  const positionBlock = getEventPositionBlock({node, slateEditor, event})\n  const selection = getEventSelection({\n    schema,\n    slateEditor,\n    event,\n  })\n\n  if (block && positionBlock && !selection && !Editor.isEditor(node)) {\n    return {\n      block: positionBlock,\n      isEditor: false,\n      selection: {\n        anchor: utils.getBlockStartPoint({\n          node: block,\n          path: [{_key: block._key}],\n        }),\n        focus: utils.getBlockEndPoint({\n          node: block,\n          path: [{_key: block._key}],\n        }),\n      },\n    }\n  }\n\n  if (!positionBlock || !selection) {\n    return undefined\n  }\n\n  const focusBlockPath = selection.focus.path.at(0)\n  const focusBlockKey = utils.isKeyedSegment(focusBlockPath)\n    ? focusBlockPath._key\n    : undefined\n\n  if (!focusBlockKey) {\n    return undefined\n  }\n\n  if (\n    utils.isSelectionCollapsed(selection) &&\n    block &&\n    focusBlockKey !== block._key\n  ) {\n    return {\n      block: positionBlock,\n      isEditor: false,\n      selection: {\n        anchor: utils.getBlockStartPoint({\n          node: block,\n          path: [{_key: block._key}],\n        }),\n        focus: utils.getBlockEndPoint({\n          node: block,\n          path: [{_key: block._key}],\n        }),\n      },\n    }\n  }\n\n  return {\n    block: positionBlock,\n    isEditor: Editor.isEditor(node),\n    selection,\n  }\n}\n\nexport function getEventNode({\n  slateEditor,\n  event,\n}: {\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}) {\n  if (!DOMEditor.hasTarget(slateEditor, event.target)) {\n    return undefined\n  }\n\n  const node = DOMEditor.toSlateNode(slateEditor, event.target)\n\n  return node\n}\n\nfunction getEventPositionBlock({\n  node,\n  slateEditor,\n  event,\n}: {\n  node: Node\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}): EventPositionBlock | undefined {\n  const [firstBlock] = getFirstBlock({editor: slateEditor})\n\n  if (!firstBlock) {\n    return undefined\n  }\n\n  const firstBlockElement = DOMEditor.toDOMNode(slateEditor, firstBlock)\n  const firstBlockRect = firstBlockElement.getBoundingClientRect()\n\n  if (event.pageY < firstBlockRect.top) {\n    return 'start'\n  }\n\n  const [lastBlock] = getLastBlock({editor: slateEditor})\n\n  if (!lastBlock) {\n    return undefined\n  }\n\n  const lastBlockElement = DOMEditor.toDOMNode(slateEditor, lastBlock)\n  const lastBlockRef = lastBlockElement.getBoundingClientRect()\n\n  if (event.pageY > lastBlockRef.bottom) {\n    return 'end'\n  }\n\n  const element = DOMEditor.toDOMNode(slateEditor, node)\n  const elementRect = element.getBoundingClientRect()\n  const top = elementRect.top\n  const height = elementRect.height\n  const location = Math.abs(top - event.pageY)\n\n  return location < height / 2 ? 'start' : 'end'\n}\n\nexport function getEventSelection({\n  schema,\n  slateEditor,\n  event,\n}: {\n  schema: EditorSchema\n  slateEditor: PortableTextSlateEditor\n  event: DragEvent | MouseEvent\n}): EditorSelection {\n  const range = getSlateRangeFromEvent(slateEditor, event)\n\n  const selection = range\n    ? toPortableTextRange(\n        fromSlateValue(slateEditor.children, schema.block.name),\n        range,\n        schema,\n      )\n    : null\n\n  return selection\n}\n\nfunction getSlateRangeFromEvent(\n  editor: PortableTextSlateEditor,\n  event: DragEvent | MouseEvent,\n) {\n  if (!event.target) {\n    return undefined\n  }\n\n  if (!isDOMNode(event.target)) {\n    return undefined\n  }\n\n  const window = DOMEditor.getWindow(editor)\n\n  let domRange: Range | undefined\n\n  if (window.document.caretPositionFromPoint !== undefined) {\n    const position = window.document.caretPositionFromPoint(\n      event.clientX,\n      event.clientY,\n    )\n\n    if (position) {\n      try {\n        domRange = window.document.createRange()\n        domRange.setStart(position.offsetNode, position.offset)\n        domRange.setEnd(position.offsetNode, position.offset)\n      } catch {}\n    }\n  } else if (window.document.caretRangeFromPoint !== undefined) {\n    // Use WebKit-proprietary fallback method\n    domRange =\n      window.document.caretRangeFromPoint(event.clientX, event.clientY) ??\n      undefined\n  } else {\n    console.warn(\n      'Neither caretPositionFromPoint nor caretRangeFromPoint is supported',\n    )\n    return undefined\n  }\n\n  if (!domRange) {\n    return undefined\n  }\n\n  let range: BaseRange | undefined\n\n  try {\n    range = DOMEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      // It can still throw even with this option set to true\n      suppressThrow: false,\n    })\n  } catch {}\n\n  return range\n}\n","import type {Path, PortableTextBlock} from '@sanity/types'\nimport {isEqual} from 'lodash'\nimport type {EditorSelection, EditorSelectionPoint} from '../types/editor'\n\nexport function normalizePoint(\n  point: EditorSelectionPoint,\n  value: PortableTextBlock[],\n): EditorSelectionPoint | null {\n  if (!point || !value) {\n    return null\n  }\n  const newPath: Path = []\n  let newOffset: number = point.offset || 0\n  const blockKey =\n    typeof point.path[0] === 'object' &&\n    '_key' in point.path[0] &&\n    point.path[0]._key\n  const childKey =\n    typeof point.path[2] === 'object' &&\n    '_key' in point.path[2] &&\n    point.path[2]._key\n  const block: PortableTextBlock | undefined = value.find(\n    (blk) => blk._key === blockKey,\n  )\n  if (block) {\n    newPath.push({_key: block._key})\n  } else {\n    return null\n  }\n  if (block && point.path[1] === 'children') {\n    if (\n      !block.children ||\n      (Array.isArray(block.children) && block.children.length === 0)\n    ) {\n      return null\n    }\n    const child =\n      Array.isArray(block.children) &&\n      block.children.find((cld) => cld._key === childKey)\n    if (child) {\n      newPath.push('children')\n      newPath.push({_key: child._key})\n      newOffset =\n        child.text && child.text.length >= point.offset\n          ? point.offset\n          : (child.text && child.text.length) || 0\n    } else {\n      return null\n    }\n  }\n  return {path: newPath, offset: newOffset}\n}\n\nexport function normalizeSelection(\n  selection: EditorSelection,\n  value: PortableTextBlock[] | undefined,\n): EditorSelection | null {\n  if (!selection || !value || value.length === 0) {\n    return null\n  }\n  let newAnchor: EditorSelectionPoint | null = null\n  let newFocus: EditorSelectionPoint | null = null\n  const {anchor, focus} = selection\n  if (\n    anchor &&\n    value.find((blk) => isEqual({_key: blk._key}, anchor.path[0]))\n  ) {\n    newAnchor = normalizePoint(anchor, value)\n  }\n  if (focus && value.find((blk) => isEqual({_key: blk._key}, focus.path[0]))) {\n    newFocus = normalizePoint(focus, value)\n  }\n  if (newAnchor && newFocus) {\n    return {anchor: newAnchor, focus: newFocus, backward: selection.backward}\n  }\n  return null\n}\n","import {Editor} from 'slate'\nimport {DOMEditor} from 'slate-dom'\nimport type {EditorSnapshot} from '..'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport {toSlateRange} from './ranges'\n\nexport type SelectionDomNodes = {\n  blockNodes: Array<Node>\n  childNodes: Array<Node>\n}\n\nexport function getSelectionDomNodes({\n  slateEditor,\n  snapshot,\n}: {\n  slateEditor: PortableTextSlateEditor\n  snapshot: EditorSnapshot\n}): SelectionDomNodes {\n  if (!snapshot.context.selection) {\n    return {\n      blockNodes: [],\n      childNodes: [],\n    }\n  }\n\n  const range = toSlateRange(snapshot.context.selection, slateEditor)\n\n  if (!range) {\n    return {\n      blockNodes: [],\n      childNodes: [],\n    }\n  }\n\n  const blockEntries = Array.from(\n    Editor.nodes(slateEditor, {\n      at: range,\n      mode: 'highest',\n      match: (n) => !Editor.isEditor(n),\n    }),\n  )\n\n  const childEntries = Array.from(\n    Editor.nodes(slateEditor, {\n      at: range,\n      mode: 'lowest',\n      match: (n) =>\n        (!Editor.isEditor(n) && slateEditor.isTextSpan(n)) ||\n        !slateEditor.isBlock(n),\n    }),\n  )\n\n  return {\n    blockNodes: blockEntries.map(([blockNode]) =>\n      DOMEditor.toDOMNode(slateEditor, blockNode),\n    ),\n    childNodes: childEntries.map(([childNode]) =>\n      DOMEditor.toDOMNode(slateEditor, childNode),\n    ),\n  }\n}\n","import type {PortableTextBlock, PortableTextChild} from '@sanity/types'\n\nexport function DefaultBlockObject(props: {\n  value: PortableTextBlock | PortableTextChild\n}) {\n  return (\n    <div style={{userSelect: 'none'}}>\n      [{props.value._type}: {props.value._key}]\n    </div>\n  )\n}\n\nexport function DefaultInlineObject(props: {\n  value: PortableTextBlock | PortableTextChild\n}) {\n  return (\n    <span style={{userSelect: 'none'}}>\n      [{props.value._type}: {props.value._key}]\n    </span>\n  )\n}\n","export function DropIndicator() {\n  return (\n    <div\n      contentEditable={false}\n      className=\"pt-drop-indicator\"\n      style={{\n        position: 'absolute',\n        width: '100%',\n        height: 1,\n        borderBottom: '1px solid currentColor',\n        zIndex: 5,\n      }}\n    >\n      <span />\n    </div>\n  )\n}\n","import type {\n  Path,\n  PortableTextChild,\n  PortableTextObject,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport {\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type FunctionComponent,\n  type JSX,\n  type ReactElement,\n} from 'react'\nimport {Editor, Range, Element as SlateElement} from 'slate'\nimport {\n  ReactEditor,\n  useSelected,\n  useSlateStatic,\n  type RenderElementProps,\n} from 'slate-react'\nimport {defineBehavior} from '../../behaviors'\nimport {debugWithName} from '../../internal-utils/debug'\nimport type {EventPositionBlock} from '../../internal-utils/event-position'\nimport {fromSlateValue} from '../../internal-utils/values'\nimport {KEY_TO_VALUE_ELEMENT} from '../../internal-utils/weakMaps'\nimport * as selectors from '../../selectors'\nimport type {\n  BlockRenderProps,\n  PortableTextMemberSchemaTypes,\n  RenderBlockFunction,\n  RenderChildFunction,\n  RenderListItemFunction,\n  RenderStyleFunction,\n} from '../../types/editor'\nimport {EditorActorContext} from '../editor-actor-context'\nimport {DefaultBlockObject, DefaultInlineObject} from './DefaultObject'\nimport {DropIndicator} from './drop-indicator'\n\nconst debug = debugWithName('components:Element')\nconst debugRenders = false\nconst EMPTY_ANNOTATIONS: PortableTextObject[] = []\n\n/**\n * @internal\n */\nexport interface ElementProps {\n  attributes: RenderElementProps['attributes']\n  children: ReactElement<any>\n  element: SlateElement\n  schemaTypes: PortableTextMemberSchemaTypes\n  readOnly: boolean\n  renderBlock?: RenderBlockFunction\n  renderChild?: RenderChildFunction\n  renderListItem?: RenderListItemFunction\n  renderStyle?: RenderStyleFunction\n  spellCheck?: boolean\n}\n\nconst inlineBlockStyle = {display: 'inline-block'}\n\n/**\n * Renders Portable Text block and inline object nodes in Slate\n * @internal\n */\nexport const Element: FunctionComponent<ElementProps> = ({\n  attributes,\n  children,\n  element,\n  schemaTypes,\n  readOnly,\n  renderBlock,\n  renderChild,\n  renderListItem,\n  renderStyle,\n  spellCheck,\n}) => {\n  const editorActor = useContext(EditorActorContext)\n  const slateEditor = useSlateStatic()\n  const selected = useSelected()\n  const blockRef = useRef<HTMLDivElement | null>(null)\n  const inlineBlockObjectRef = useRef(null)\n  const focused =\n    (selected &&\n      slateEditor.selection &&\n      Range.isCollapsed(slateEditor.selection)) ||\n    false\n  const [dragPositionBlock, setDragPositionBlock] =\n    useState<EventPositionBlock>()\n\n  useEffect(() => {\n    const behavior = defineBehavior({\n      on: 'drag.dragover',\n      guard: ({snapshot, event}) => {\n        const dropFocusBlock = selectors.getFocusBlock({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: event.position.selection,\n          },\n        })\n\n        if (!dropFocusBlock || dropFocusBlock.node._key !== element._key) {\n          return false\n        }\n\n        const dragOrigin = snapshot.beta.internalDrag?.origin\n\n        if (!dragOrigin) {\n          return false\n        }\n\n        const draggedBlocks = selectors.getSelectedBlocks({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: dragOrigin.selection,\n          },\n        })\n\n        if (\n          draggedBlocks.some(\n            (draggedBlock) => draggedBlock.node._key === element._key,\n          )\n        ) {\n          return false\n        }\n\n        const draggingEntireBlocks = selectors.isSelectingEntireBlocks({\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: dragOrigin.selection,\n          },\n        })\n\n        return draggingEntireBlocks\n      },\n      actions: [\n        ({event}) => [\n          {\n            type: 'effect',\n            effect: () => {\n              setDragPositionBlock(event.position.block)\n            },\n          },\n          {\n            type: 'noop',\n          },\n        ],\n      ],\n    })\n\n    editorActor.send({\n      type: 'add behavior',\n      behavior,\n    })\n\n    return () => {\n      editorActor.send({\n        type: 'remove behavior',\n        behavior,\n      })\n    }\n  }, [editorActor, element._key])\n\n  useEffect(() => {\n    const behavior = defineBehavior({\n      on: 'drag.*',\n      guard: ({event}) => {\n        return event.type !== 'drag.dragover'\n      },\n      actions: [\n        () => [\n          {\n            type: 'effect',\n            effect: () => {\n              setDragPositionBlock(undefined)\n            },\n          },\n        ],\n      ],\n    })\n\n    editorActor.send({\n      type: 'add behavior',\n      behavior,\n    })\n\n    return () => {\n      editorActor.send({\n        type: 'remove behavior',\n        behavior,\n      })\n    }\n  }, [editorActor])\n\n  const value = useMemo(\n    () =>\n      fromSlateValue(\n        [element],\n        schemaTypes.block.name,\n        KEY_TO_VALUE_ELEMENT.get(slateEditor),\n      )[0],\n    [slateEditor, element, schemaTypes.block.name],\n  )\n\n  let renderedBlock = children\n\n  let className: string | undefined\n\n  const blockPath: Path = useMemo(() => [{_key: element._key}], [element])\n\n  if (typeof element._type !== 'string') {\n    throw new Error(`Expected element to have a _type property`)\n  }\n\n  if (typeof element._key !== 'string') {\n    throw new Error(`Expected element to have a _key property`)\n  }\n\n  // Test for inline objects first\n  if (slateEditor.isInline(element)) {\n    const path = ReactEditor.findPath(slateEditor, element)\n    const [block] = Editor.node(slateEditor, path, {depth: 1})\n    const schemaType = schemaTypes.inlineObjects.find(\n      (_type) => _type.name === element._type,\n    )\n    if (!schemaType) {\n      throw new Error('Could not find type for inline block element')\n    }\n    if (SlateElement.isElement(block)) {\n      const elmPath: Path = [\n        {_key: block._key},\n        'children',\n        {_key: element._key},\n      ]\n      if (debugRenders) {\n        debug(`Render ${element._key} (inline object)`)\n      }\n      return (\n        <span {...attributes}>\n          {/* Note that children must follow immediately or cut and selections will not work properly in Chrome. */}\n          {children}\n          <span\n            draggable={!readOnly}\n            className=\"pt-inline-object\"\n            data-testid=\"pt-inline-object\"\n            ref={inlineBlockObjectRef}\n            key={element._key}\n            style={inlineBlockStyle}\n            contentEditable={false}\n          >\n            {renderChild &&\n              renderChild({\n                annotations: EMPTY_ANNOTATIONS, // These inline objects currently doesn't support annotations. This is a limitation of the current PT spec/model.\n                children: <DefaultInlineObject value={value} />,\n                editorElementRef: inlineBlockObjectRef,\n                focused,\n                path: elmPath,\n                schemaType,\n                selected,\n                type: schemaType,\n                value: value as PortableTextChild,\n              })}\n            {!renderChild && <DefaultInlineObject value={value} />}\n          </span>\n        </span>\n      )\n    }\n    throw new Error('Block not found!')\n  }\n\n  // If not inline, it's either a block (text) or a block object (non-text)\n  // NOTE: text blocks aren't draggable with DraggableBlock (yet?)\n  if (element._type === schemaTypes.block.name) {\n    className = `pt-block pt-text-block`\n    const isListItem = 'listItem' in element\n    if (debugRenders) {\n      debug(`Render ${element._key} (text block)`)\n    }\n    const style = ('style' in element && element.style) || 'normal'\n    className = `pt-block pt-text-block pt-text-block-style-${style}`\n    const blockStyleType = schemaTypes.styles.find(\n      (item) => item.value === style,\n    )\n    if (renderStyle && blockStyleType) {\n      renderedBlock = renderStyle({\n        block: element as PortableTextTextBlock,\n        children,\n        focused,\n        selected,\n        value: style,\n        path: blockPath,\n        schemaType: blockStyleType,\n        editorElementRef: blockRef,\n      })\n    }\n    let level: number | undefined\n\n    if (isListItem) {\n      if (typeof element.level === 'number') {\n        level = element.level\n      }\n      className += ` pt-list-item pt-list-item-${element.listItem} pt-list-item-level-${level || 1}`\n    }\n\n    if (slateEditor.isListBlock(value) && isListItem && element.listItem) {\n      const listType = schemaTypes.lists.find(\n        (item) => item.value === element.listItem,\n      )\n      if (renderListItem && listType) {\n        renderedBlock = renderListItem({\n          block: value,\n          children: renderedBlock,\n          focused,\n          selected,\n          value: element.listItem,\n          path: blockPath,\n          schemaType: listType,\n          level: value.level || 1,\n          editorElementRef: blockRef,\n        })\n      }\n    }\n\n    const renderProps: Omit<BlockRenderProps, 'type'> = Object.defineProperty(\n      {\n        children: renderedBlock,\n        editorElementRef: blockRef,\n        focused,\n        level,\n        listItem: isListItem ? element.listItem : undefined,\n        path: blockPath,\n        selected,\n        style,\n        schemaType: schemaTypes.block,\n        value,\n      },\n      'type',\n      {\n        enumerable: false,\n        get() {\n          console.warn(\n            \"Property 'type' is deprecated, use 'schemaType' instead.\",\n          )\n          return schemaTypes.block\n        },\n      },\n    )\n\n    const propsOrDefaultRendered = renderBlock\n      ? renderBlock(renderProps as BlockRenderProps)\n      : children\n\n    return (\n      <div\n        key={element._key}\n        {...attributes}\n        className={className}\n        spellCheck={spellCheck}\n      >\n        {dragPositionBlock === 'start' ? <DropIndicator /> : null}\n        <div ref={blockRef}>{propsOrDefaultRendered}</div>\n        {dragPositionBlock === 'end' ? <DropIndicator /> : null}\n      </div>\n    )\n  }\n\n  const schemaType = schemaTypes.blockObjects.find(\n    (_type) => _type.name === element._type,\n  )\n\n  if (!schemaType) {\n    throw new Error(\n      `Could not find schema type for block element of _type ${element._type}`,\n    )\n  }\n\n  if (debugRenders) {\n    debug(`Render ${element._key} (object block)`)\n  }\n\n  className = 'pt-block pt-object-block'\n\n  const block = fromSlateValue(\n    [element],\n    schemaTypes.block.name,\n    KEY_TO_VALUE_ELEMENT.get(slateEditor),\n  )[0]\n\n  let renderedBlockFromProps: JSX.Element | undefined\n\n  if (renderBlock) {\n    const _props: Omit<BlockRenderProps, 'type'> = Object.defineProperty(\n      {\n        children: <DefaultBlockObject value={value} />,\n        editorElementRef: blockRef,\n        focused,\n        path: blockPath,\n        schemaType,\n        selected,\n        value: block,\n      },\n      'type',\n      {\n        enumerable: false,\n        get() {\n          console.warn(\n            \"Property 'type' is deprecated, use 'schemaType' instead.\",\n          )\n          return schemaType\n        },\n      },\n    )\n    renderedBlockFromProps = renderBlock(_props as BlockRenderProps)\n  }\n\n  return (\n    <div key={element._key} {...attributes} className={className}>\n      {dragPositionBlock === 'start' ? <DropIndicator /> : null}\n      {children}\n      <div ref={blockRef} contentEditable={false} draggable={!readOnly}>\n        {renderedBlockFromProps ? (\n          renderedBlockFromProps\n        ) : (\n          <DefaultBlockObject value={value} />\n        )}\n      </div>\n      {dragPositionBlock === 'end' ? <DropIndicator /> : null}\n    </div>\n  )\n}\n\nElement.displayName = 'Element'\n","import type {\n  Path,\n  PortableTextObject,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport {isEqual, uniq} from 'lodash'\nimport {\n  startTransition,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  type ReactElement,\n} from 'react'\nimport {Text} from 'slate'\nimport {useSelected, type RenderLeafProps} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport type {\n  BlockAnnotationRenderProps,\n  BlockChildRenderProps,\n  BlockDecoratorRenderProps,\n  PortableTextMemberSchemaTypes,\n  RenderAnnotationFunction,\n  RenderChildFunction,\n  RenderDecoratorFunction,\n} from '../../types/editor'\nimport type {EditorActor} from '../editor-machine'\nimport {usePortableTextEditor} from '../hooks/usePortableTextEditor'\nimport {PortableTextEditor} from '../PortableTextEditor'\n\nconst debug = debugWithName('components:Leaf')\n\nconst EMPTY_MARKS: string[] = []\n\n/**\n * @internal\n */\nexport interface LeafProps extends RenderLeafProps {\n  editorActor: EditorActor\n  children: ReactElement<any>\n  schemaTypes: PortableTextMemberSchemaTypes\n  renderAnnotation?: RenderAnnotationFunction\n  renderChild?: RenderChildFunction\n  renderDecorator?: RenderDecoratorFunction\n  readOnly: boolean\n}\n\n/**\n * Renders Portable Text span nodes in Slate\n * @internal\n */\nexport const Leaf = (props: LeafProps) => {\n  const {\n    editorActor,\n    attributes,\n    children,\n    leaf,\n    schemaTypes,\n    renderChild,\n    renderDecorator,\n    renderAnnotation,\n  } = props\n  const spanRef = useRef<HTMLElement>(null)\n  const portableTextEditor = usePortableTextEditor()\n  const blockSelected = useSelected()\n  const [focused, setFocused] = useState(false)\n  const [selected, setSelected] = useState(false)\n  const block = children.props.parent as PortableTextTextBlock | undefined\n  const path: Path = useMemo(\n    () => (block ? [{_key: block?._key}, 'children', {_key: leaf._key}] : []),\n    [block, leaf._key],\n  )\n  const decoratorValues = useMemo(\n    () => schemaTypes.decorators.map((dec) => dec.value),\n    [schemaTypes.decorators],\n  )\n  const marks: string[] = useMemo(\n    () =>\n      uniq(\n        (leaf.marks || EMPTY_MARKS).filter((mark) =>\n          decoratorValues.includes(mark),\n        ),\n      ),\n    [decoratorValues, leaf.marks],\n  )\n  const annotationMarks = Array.isArray(leaf.marks) ? leaf.marks : EMPTY_MARKS\n  const annotations = useMemo(\n    () =>\n      annotationMarks\n        .map(\n          (mark) =>\n            !decoratorValues.includes(mark) &&\n            block?.markDefs?.find((def) => def._key === mark),\n        )\n        .filter(Boolean) as PortableTextObject[],\n    [annotationMarks, block, decoratorValues],\n  )\n\n  const shouldTrackSelectionAndFocus = annotations.length > 0 && blockSelected\n\n  useEffect(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      setFocused(false)\n      return\n    }\n    const sel = PortableTextEditor.getSelection(portableTextEditor)\n    if (\n      sel &&\n      isEqual(sel.focus.path, path) &&\n      PortableTextEditor.isCollapsedSelection(portableTextEditor)\n    ) {\n      startTransition(() => {\n        setFocused(true)\n      })\n    }\n  }, [shouldTrackSelectionAndFocus, path, portableTextEditor])\n\n  // Function to check if this leaf is currently inside the user's text selection\n  const setSelectedFromRange = useCallback(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      return\n    }\n    debug('Setting selection and focus from range')\n    const winSelection = window.getSelection()\n    if (!winSelection) {\n      setSelected(false)\n      return\n    }\n    if (winSelection && winSelection.rangeCount > 0) {\n      const range = winSelection.getRangeAt(0)\n      if (spanRef.current && range.intersectsNode(spanRef.current)) {\n        setSelected(true)\n      } else {\n        setSelected(false)\n      }\n    } else {\n      setSelected(false)\n    }\n  }, [shouldTrackSelectionAndFocus])\n\n  useEffect(() => {\n    if (!shouldTrackSelectionAndFocus) {\n      return undefined\n    }\n\n    const onBlur = editorActor.on('blur', () => {\n      setFocused(false)\n      setSelected(false)\n    })\n\n    const onFocus = editorActor.on('focus', () => {\n      const sel = PortableTextEditor.getSelection(portableTextEditor)\n      if (\n        sel &&\n        isEqual(sel.focus.path, path) &&\n        PortableTextEditor.isCollapsedSelection(portableTextEditor)\n      ) {\n        setFocused(true)\n      }\n      setSelectedFromRange()\n    })\n\n    const onSelection = editorActor.on('selection', (event) => {\n      if (\n        event.selection &&\n        isEqual(event.selection.focus.path, path) &&\n        PortableTextEditor.isCollapsedSelection(portableTextEditor)\n      ) {\n        setFocused(true)\n      } else {\n        setFocused(false)\n      }\n      setSelectedFromRange()\n    })\n\n    return () => {\n      onBlur.unsubscribe()\n      onFocus.unsubscribe()\n      onSelection.unsubscribe()\n    }\n  }, [\n    editorActor,\n    path,\n    portableTextEditor,\n    setSelectedFromRange,\n    shouldTrackSelectionAndFocus,\n  ])\n\n  useEffect(() => setSelectedFromRange(), [setSelectedFromRange])\n\n  const content = useMemo(() => {\n    let returnedChildren = children\n    // Render text nodes\n    if (Text.isText(leaf) && leaf._type === schemaTypes.span.name) {\n      marks.forEach((mark) => {\n        const schemaType = schemaTypes.decorators.find(\n          (dec) => dec.value === mark,\n        )\n        if (schemaType && renderDecorator) {\n          const _props: Omit<BlockDecoratorRenderProps, 'type'> =\n            Object.defineProperty(\n              {\n                children: returnedChildren,\n                editorElementRef: spanRef,\n                focused,\n                path,\n                selected,\n                schemaType,\n                value: mark,\n              },\n              'type',\n              {\n                enumerable: false,\n                get() {\n                  console.warn(\n                    \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                  )\n                  return schemaType\n                },\n              },\n            )\n          returnedChildren = renderDecorator(\n            _props as BlockDecoratorRenderProps,\n          )\n        }\n      })\n\n      if (block && annotations.length > 0) {\n        annotations.forEach((annotation) => {\n          const schemaType = schemaTypes.annotations.find(\n            (t) => t.name === annotation._type,\n          )\n          if (schemaType) {\n            if (renderAnnotation) {\n              const _props: Omit<BlockAnnotationRenderProps, 'type'> =\n                Object.defineProperty(\n                  {\n                    block,\n                    children: returnedChildren,\n                    editorElementRef: spanRef,\n                    focused,\n                    path,\n                    selected,\n                    schemaType,\n                    value: annotation,\n                  },\n                  'type',\n                  {\n                    enumerable: false,\n                    get() {\n                      console.warn(\n                        \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                      )\n                      return schemaType\n                    },\n                  },\n                )\n\n              returnedChildren = (\n                <span ref={spanRef}>\n                  {renderAnnotation(_props as BlockAnnotationRenderProps)}\n                </span>\n              )\n            } else {\n              returnedChildren = <span ref={spanRef}>{returnedChildren}</span>\n            }\n          }\n        })\n      }\n      if (block && renderChild) {\n        const child = block.children.find((_child) => _child._key === leaf._key) // Ensure object equality\n        if (child) {\n          const defaultRendered = <>{returnedChildren}</>\n          const _props: Omit<BlockChildRenderProps, 'type'> =\n            Object.defineProperty(\n              {\n                annotations,\n                children: defaultRendered,\n                editorElementRef: spanRef,\n                focused,\n                path,\n                schemaType: schemaTypes.span,\n                selected,\n                value: child,\n              },\n              'type',\n              {\n                enumerable: false,\n                get() {\n                  console.warn(\n                    \"Property 'type' is deprecated, use 'schemaType' instead.\",\n                  )\n                  return schemaTypes.span\n                },\n              },\n            )\n          returnedChildren = renderChild(_props as BlockChildRenderProps)\n        }\n      }\n    }\n    return returnedChildren\n  }, [\n    annotations,\n    block,\n    children,\n    focused,\n    leaf,\n    marks,\n    path,\n    renderAnnotation,\n    renderChild,\n    renderDecorator,\n    schemaTypes.annotations,\n    schemaTypes.decorators,\n    schemaTypes.span,\n    selected,\n  ])\n  return useMemo(\n    () => (\n      <span key={leaf._key} {...attributes} ref={spanRef}>\n        {content}\n      </span>\n    ),\n    [leaf, attributes, content],\n  )\n}\n\nLeaf.displayName = 'Leaf'\n","import type {KeyboardEvent} from 'react'\nimport type {ReactEditor} from 'slate-react'\nimport {debugWithName} from '../../internal-utils/debug'\nimport {isHotkey} from '../../internal-utils/is-hotkey'\nimport type {PortableTextSlateEditor} from '../../types/editor'\nimport type {HotkeyOptions} from '../../types/options'\nimport type {EditorActor} from '../editor-machine'\nimport type {PortableTextEditor} from '../PortableTextEditor'\n\nconst debug = debugWithName('plugin:withHotKeys')\n\n/**\n * This plugin takes care of all hotkeys in the editor\n *\n */\nexport function createWithHotkeys(\n  editorActor: EditorActor,\n  portableTextEditor: PortableTextEditor,\n  hotkeysFromOptions?: HotkeyOptions,\n): (editor: PortableTextSlateEditor & ReactEditor) => any {\n  const reservedHotkeys = ['enter', 'tab', 'shift', 'delete', 'end']\n  const activeHotkeys = hotkeysFromOptions ?? {}\n  return function withHotKeys(editor: PortableTextSlateEditor & ReactEditor) {\n    editor.pteWithHotKeys = (event: KeyboardEvent<HTMLDivElement>): void => {\n      // Wire up custom marks hotkeys\n      Object.keys(activeHotkeys).forEach((cat) => {\n        if (cat === 'marks') {\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey)) {\n              throw new Error(`The hotkey ${hotkey} is reserved!`)\n            }\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              event.preventDefault()\n              const possibleMark = activeHotkeys[cat]\n              if (possibleMark) {\n                const mark = possibleMark[hotkey]\n                debug(`HotKey ${hotkey} to toggle ${mark}`)\n                editorActor.send({\n                  type: 'behavior event',\n                  behaviorEvent: {\n                    type: 'decorator.toggle',\n                    decorator: mark,\n                  },\n                  editor,\n                })\n              }\n            }\n          }\n        }\n        if (cat === 'custom') {\n          for (const hotkey in activeHotkeys[cat]) {\n            if (reservedHotkeys.includes(hotkey)) {\n              throw new Error(`The hotkey ${hotkey} is reserved!`)\n            }\n            if (isHotkey(hotkey, event.nativeEvent)) {\n              const possibleCommand = activeHotkeys[cat]\n              if (possibleCommand) {\n                const command = possibleCommand[hotkey]\n                command(event, portableTextEditor)\n              }\n            }\n          }\n        }\n      })\n    }\n    return editor\n  }\n}\n","import type {BaseEditor, Operation} from 'slate'\nimport type {ReactEditor} from 'slate-react'\nimport type {PortableTextSlateEditor} from '../types/editor'\nimport type {EditorActor} from './editor-machine'\n\n// React Compiler considers `slateEditor` as immutable, and opts-out if we do this inline in a useEffect, doing it in a function moves it out of the scope, and opts-in again for the rest of the component.\nexport function withSyncRangeDecorations({\n  editorActor,\n  slateEditor,\n  syncRangeDecorations,\n}: {\n  editorActor: EditorActor\n  slateEditor: BaseEditor & ReactEditor & PortableTextSlateEditor\n  syncRangeDecorations: (operation?: Operation) => void\n}) {\n  const originalApply = slateEditor.apply\n\n  slateEditor.apply = (op: Operation) => {\n    originalApply(op)\n\n    if (\n      !editorActor.getSnapshot().matches({'edit mode': 'read only'}) &&\n      op.type !== 'set_selection'\n    ) {\n      syncRangeDecorations(op)\n    }\n  }\n\n  return () => {\n    slateEditor.apply = originalApply\n  }\n}\n","import {useSelector} from '@xstate/react'\nimport {isEqual, noop} from 'lodash'\nimport {\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState,\n  type ClipboardEvent,\n  type CSSProperties,\n  type FocusEventHandler,\n  type KeyboardEvent,\n  type MutableRefObject,\n  type TextareaHTMLAttributes,\n} from 'react'\nimport {\n  Editor,\n  Path,\n  Range as SlateRange,\n  Transforms,\n  type BaseRange,\n  type NodeEntry,\n  type Operation,\n  type Text,\n} from 'slate'\nimport {\n  ReactEditor,\n  Editable as SlateEditable,\n  useSlate,\n  type RenderElementProps,\n  type RenderLeafProps,\n} from 'slate-react'\nimport {getCompoundClientRect} from '../internal-utils/compound-client-rect'\nimport {debugWithName} from '../internal-utils/debug'\nimport {getDragSelection} from '../internal-utils/drag-selection'\nimport {getEventPosition} from '../internal-utils/event-position'\nimport {parseBlocks} from '../internal-utils/parse-blocks'\nimport {\n  moveRangeByOperation,\n  toPortableTextRange,\n  toSlateRange,\n} from '../internal-utils/ranges'\nimport {normalizeSelection} from '../internal-utils/selection'\nimport {getSelectionDomNodes} from '../internal-utils/selection-elements'\nimport {fromSlateValue, isEqualToEmptyEditor} from '../internal-utils/values'\nimport * as selectors from '../selectors'\nimport type {\n  EditorSelection,\n  OnCopyFn,\n  OnPasteFn,\n  RangeDecoration,\n  RenderAnnotationFunction,\n  RenderBlockFunction,\n  RenderChildFunction,\n  RenderDecoratorFunction,\n  RenderListItemFunction,\n  RenderPlaceholderFunction,\n  RenderStyleFunction,\n  ScrollSelectionIntoViewFunction,\n} from '../types/editor'\nimport type {HotkeyOptions} from '../types/options'\nimport {isSelectionCollapsed} from '../utils'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {Element} from './components/Element'\nimport {Leaf} from './components/Leaf'\nimport {EditorActorContext} from './editor-actor-context'\nimport {getEditorSnapshot} from './editor-selector'\nimport {usePortableTextEditor} from './hooks/usePortableTextEditor'\nimport {createWithHotkeys} from './plugins/createWithHotKeys'\nimport {PortableTextEditor} from './PortableTextEditor'\nimport {withSyncRangeDecorations} from './withSyncRangeDecorations'\n\nconst debug = debugWithName('component:Editable')\n\nconst PLACEHOLDER_STYLE: CSSProperties = {\n  position: 'absolute',\n  userSelect: 'none',\n  pointerEvents: 'none',\n  left: 0,\n  right: 0,\n}\n\ninterface BaseRangeWithDecoration extends BaseRange {\n  rangeDecoration: RangeDecoration\n}\n\n/**\n * @public\n */\nexport type PortableTextEditableProps = Omit<\n  TextareaHTMLAttributes<HTMLDivElement>,\n  'onPaste' | 'onCopy' | 'onBeforeInput'\n> & {\n  hotkeys?: HotkeyOptions\n  onBeforeInput?: (event: InputEvent) => void\n  onPaste?: OnPasteFn\n  onCopy?: OnCopyFn\n  ref: MutableRefObject<HTMLDivElement | null>\n  rangeDecorations?: RangeDecoration[]\n  renderAnnotation?: RenderAnnotationFunction\n  renderBlock?: RenderBlockFunction\n  renderChild?: RenderChildFunction\n  renderDecorator?: RenderDecoratorFunction\n  renderListItem?: RenderListItemFunction\n  renderPlaceholder?: RenderPlaceholderFunction\n  renderStyle?: RenderStyleFunction\n  scrollSelectionIntoView?: ScrollSelectionIntoViewFunction\n  selection?: EditorSelection\n  spellCheck?: boolean\n}\n\n/**\n * @public\n *\n *\n * The core component that renders the editor. Must be placed within the {@link EditorProvider} component.\n *\n * @example\n * ```tsx\n * import { PortableTextEditable, EditorProvider } from '@portabletext/editor'\n *\n * function MyComponent() {\n *  return (\n *   <EditorProvider>\n *    <PortableTextEditable />\n *  </EditorProvider>\n *  )\n * }\n * ```\n * @group Components\n */\nexport const PortableTextEditable = forwardRef<\n  Omit<HTMLDivElement, 'as' | 'onPaste' | 'onBeforeInput'>,\n  PortableTextEditableProps\n>(function PortableTextEditable(props, forwardedRef) {\n  const {\n    hotkeys,\n    onBlur,\n    onFocus,\n    onBeforeInput,\n    onPaste,\n    onCopy,\n    onCut,\n    onClick,\n    onDragStart,\n    onDrag,\n    onDragEnd,\n    onDragEnter,\n    onDragOver,\n    onDrop,\n    onDragLeave,\n    rangeDecorations,\n    renderAnnotation,\n    renderBlock,\n    renderChild,\n    renderDecorator,\n    renderListItem,\n    renderPlaceholder,\n    renderStyle,\n    selection: propsSelection,\n    scrollSelectionIntoView,\n    spellCheck,\n    ...restProps\n  } = props\n\n  const portableTextEditor = usePortableTextEditor()\n  const ref = useRef<HTMLDivElement | null>(null)\n  const [editableElement, setEditableElement] = useState<HTMLDivElement | null>(\n    null,\n  )\n  const [hasInvalidValue, setHasInvalidValue] = useState(false)\n  const [rangeDecorationState, setRangeDecorationsState] = useState<\n    BaseRangeWithDecoration[]\n  >([])\n\n  // Forward ref to parent component\n  useImperativeHandle<HTMLDivElement | null, HTMLDivElement | null>(\n    forwardedRef,\n    () => ref.current,\n  )\n\n  const rangeDecorationsRef = useRef(rangeDecorations)\n\n  const editorActor = useContext(EditorActorContext)\n  const readOnly = useSelector(editorActor, (s) =>\n    s.matches({'edit mode': 'read only'}),\n  )\n  const schemaTypes = useSelector(editorActor, (s) => s.context.schema)\n  const slateEditor = useSlate()\n\n  const blockTypeName = schemaTypes.block.name\n\n  // Output a minimal React editor inside Editable when in readOnly mode.\n  // NOTE: make sure all the plugins used here can be safely run over again at any point.\n  // There will be a problem if they redefine editor methods and then calling the original method within themselves.\n  useMemo(() => {\n    // React/UI-specific plugins\n    if (readOnly) {\n      debug('Editable is in read only mode')\n      return slateEditor\n    }\n    const withHotKeys = createWithHotkeys(\n      editorActor,\n      portableTextEditor,\n      hotkeys,\n    )\n\n    debug('Editable is in edit mode')\n    return withHotKeys(slateEditor)\n  }, [editorActor, hotkeys, portableTextEditor, readOnly, slateEditor])\n\n  const renderElement = useCallback(\n    (eProps: RenderElementProps) => (\n      <Element\n        {...eProps}\n        readOnly={readOnly}\n        renderBlock={renderBlock}\n        renderChild={renderChild}\n        renderListItem={renderListItem}\n        renderStyle={renderStyle}\n        schemaTypes={schemaTypes}\n        spellCheck={spellCheck}\n      />\n    ),\n    [\n      schemaTypes,\n      spellCheck,\n      readOnly,\n      renderBlock,\n      renderChild,\n      renderListItem,\n      renderStyle,\n    ],\n  )\n\n  const renderLeaf = useCallback(\n    (\n      lProps: RenderLeafProps & {\n        leaf: Text & {placeholder?: boolean; rangeDecoration?: RangeDecoration}\n      },\n    ) => {\n      if (lProps.leaf._type === 'span') {\n        let rendered = (\n          <Leaf\n            {...lProps}\n            editorActor={editorActor}\n            schemaTypes={schemaTypes}\n            renderAnnotation={renderAnnotation}\n            renderChild={renderChild}\n            renderDecorator={renderDecorator}\n            readOnly={readOnly}\n          />\n        )\n        if (\n          renderPlaceholder &&\n          lProps.leaf.placeholder &&\n          lProps.text.text === ''\n        ) {\n          return (\n            <>\n              <span style={PLACEHOLDER_STYLE} contentEditable={false}>\n                {renderPlaceholder()}\n              </span>\n              {rendered}\n            </>\n          )\n        }\n        const decoration = lProps.leaf.rangeDecoration\n        if (decoration) {\n          rendered = decoration.component({children: rendered})\n        }\n        return rendered\n      }\n      return lProps.children\n    },\n    [\n      editorActor,\n      readOnly,\n      renderAnnotation,\n      renderChild,\n      renderDecorator,\n      renderPlaceholder,\n      schemaTypes,\n    ],\n  )\n\n  const restoreSelectionFromProps = useCallback(() => {\n    if (propsSelection) {\n      debug(`Selection from props ${JSON.stringify(propsSelection)}`)\n      const normalizedSelection = normalizeSelection(\n        propsSelection,\n        fromSlateValue(slateEditor.children, blockTypeName),\n      )\n      if (normalizedSelection !== null) {\n        debug(\n          `Normalized selection from props ${JSON.stringify(normalizedSelection)}`,\n        )\n        const slateRange = toSlateRange(normalizedSelection, slateEditor)\n        if (slateRange) {\n          Transforms.select(slateEditor, slateRange)\n          // Output selection here in those cases where the editor selection was the same, and there are no set_selection operations made.\n          // The selection is usually automatically emitted to change$ by the withPortableTextSelections plugin whenever there is a set_selection operation applied.\n          if (!slateEditor.operations.some((o) => o.type === 'set_selection')) {\n            editorActor.send({\n              type: 'notify.selection',\n              selection: normalizedSelection,\n            })\n          }\n          slateEditor.onChange()\n        }\n      }\n    }\n  }, [blockTypeName, editorActor, propsSelection, slateEditor])\n\n  const syncRangeDecorations = useCallback(\n    (operation?: Operation) => {\n      if (rangeDecorations && rangeDecorations.length > 0) {\n        const newSlateRanges: BaseRangeWithDecoration[] = []\n        rangeDecorations.forEach((rangeDecorationItem) => {\n          const slateRange = toSlateRange(\n            rangeDecorationItem.selection,\n            slateEditor,\n          )\n          if (!SlateRange.isRange(slateRange)) {\n            if (rangeDecorationItem.onMoved) {\n              rangeDecorationItem.onMoved({\n                newSelection: null,\n                rangeDecoration: rangeDecorationItem,\n                origin: 'local',\n              })\n            }\n            return\n          }\n          let newRange: BaseRange | null | undefined\n          if (operation) {\n            newRange = moveRangeByOperation(slateRange, operation)\n            if (\n              (newRange && newRange !== slateRange) ||\n              (newRange === null && slateRange)\n            ) {\n              const value = PortableTextEditor.getValue(portableTextEditor)\n              const newRangeSelection = toPortableTextRange(\n                value,\n                newRange,\n                schemaTypes,\n              )\n              if (rangeDecorationItem.onMoved) {\n                rangeDecorationItem.onMoved({\n                  newSelection: newRangeSelection,\n                  rangeDecoration: rangeDecorationItem,\n                  origin: 'local',\n                })\n              }\n            }\n          }\n          // If the newRange is null, it means that the range is not valid anymore and should be removed\n          // If it's undefined, it means that the slateRange is still valid and should be kept\n          if (newRange !== null) {\n            newSlateRanges.push({\n              ...(newRange || slateRange),\n              rangeDecoration: rangeDecorationItem,\n            })\n          }\n        })\n        if (newSlateRanges.length > 0) {\n          setRangeDecorationsState(newSlateRanges)\n          return\n        }\n      }\n      setRangeDecorationsState((rangeDecorationState) => {\n        // If there's state then we want to reset\n        if (rangeDecorationState.length > 0) {\n          return []\n        }\n        // Otherwise we no-op, React will skip a state update if what we return has reference equality to the previous state\n        return rangeDecorationState\n      })\n    },\n    [portableTextEditor, rangeDecorations, schemaTypes, slateEditor],\n  )\n\n  // Restore selection from props when the editor has been initialized properly with it's value\n  useEffect(() => {\n    const onReady = editorActor.on('ready', () => {\n      syncRangeDecorations()\n      restoreSelectionFromProps()\n    })\n    const onInvalidValue = editorActor.on('invalid value', () => {\n      setHasInvalidValue(true)\n    })\n    const onValueChanged = editorActor.on('value changed', () => {\n      setHasInvalidValue(false)\n    })\n\n    return () => {\n      onReady.unsubscribe()\n      onInvalidValue.unsubscribe()\n      onValueChanged.unsubscribe()\n    }\n  }, [editorActor, restoreSelectionFromProps, syncRangeDecorations])\n\n  // Restore selection from props when it changes\n  useEffect(() => {\n    if (propsSelection && !hasInvalidValue) {\n      restoreSelectionFromProps()\n    }\n  }, [hasInvalidValue, propsSelection, restoreSelectionFromProps])\n\n  const [syncedRangeDecorations, setSyncedRangeDecorations] = useState(false)\n  useEffect(() => {\n    if (!syncedRangeDecorations) {\n      // We only want this to run once, on mount\n      setSyncedRangeDecorations(true)\n      syncRangeDecorations()\n    }\n  }, [syncRangeDecorations, syncedRangeDecorations])\n\n  useEffect(() => {\n    if (!isEqual(rangeDecorations, rangeDecorationsRef.current)) {\n      syncRangeDecorations()\n    }\n    rangeDecorationsRef.current = rangeDecorations\n  }, [rangeDecorations, syncRangeDecorations])\n\n  // Sync range decorations after an operation is applied\n  useEffect(() => {\n    const teardown = withSyncRangeDecorations({\n      editorActor,\n      slateEditor,\n      syncRangeDecorations,\n    })\n    return () => teardown()\n  }, [editorActor, slateEditor, syncRangeDecorations])\n\n  // Handle from props onCopy function\n  const handleCopy = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>): void | ReactEditor => {\n      if (onCopy) {\n        const result = onCopy(event)\n        // CopyFn may return something to avoid doing default stuff\n        if (result !== undefined) {\n          event.preventDefault()\n        }\n      } else if (event.nativeEvent.clipboardData) {\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n        event.preventDefault()\n\n        const selection = editorActor.getSnapshot().context.selection\n        const position = selection ? {selection} : undefined\n\n        if (!position) {\n          console.warn('Could not find position for copy event')\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'clipboard.copy',\n            originEvent: {\n              dataTransfer: event.nativeEvent.clipboardData,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [onCopy, editorActor, slateEditor],\n  )\n\n  const handleCut = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>) => {\n      if (onCut) {\n        const result = onCut(event)\n        // CutFn may return something to avoid doing default stuff\n        if (result !== undefined) {\n          event.preventDefault()\n        }\n      } else if (event.nativeEvent.clipboardData) {\n        // Prevent Slate from handling the event\n        event.stopPropagation()\n        event.preventDefault()\n\n        const selection = editorActor.getSnapshot().context.selection\n        const position = selection ? {selection} : undefined\n\n        if (!position) {\n          console.warn('Could not find position for cut event')\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'clipboard.cut',\n            originEvent: {\n              dataTransfer: event.nativeEvent.clipboardData,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [onCut, editorActor, slateEditor],\n  )\n\n  // Handle incoming pasting events in the editor\n  const handlePaste = useCallback(\n    (event: ClipboardEvent<HTMLDivElement>): Promise<void> | void => {\n      const value = PortableTextEditor.getValue(portableTextEditor)\n      const ptRange = toPortableTextRange(\n        value,\n        slateEditor.selection,\n        schemaTypes,\n      )\n      const path = ptRange?.focus.path || []\n      const onPasteResult = onPaste?.({event, value, path, schemaTypes})\n\n      if (onPasteResult || !slateEditor.selection) {\n        event.preventDefault()\n\n        // Resolve it as promise (can be either async promise or sync return value)\n        editorActor.send({type: 'notify.loading'})\n\n        Promise.resolve(onPasteResult)\n          .then((result) => {\n            debug('Custom paste function from client resolved', result)\n\n            if (!result || !result.insert) {\n              debug('No result from custom paste handler, pasting normally')\n\n              const selection = editorActor.getSnapshot().context.selection\n              const position = selection ? {selection} : undefined\n\n              if (!position) {\n                console.warn('Could not find position for paste event')\n                return\n              }\n\n              editorActor.send({\n                type: 'behavior event',\n                behaviorEvent: {\n                  type: 'clipboard.paste',\n                  originEvent: {\n                    dataTransfer: event.clipboardData,\n                  },\n                  position,\n                },\n                editor: slateEditor,\n                nativeEvent: event,\n              })\n            } else if (result.insert) {\n              editorActor.send({\n                type: 'behavior event',\n                behaviorEvent: {\n                  type: 'insert.blocks',\n                  blocks: parseBlocks({\n                    context: {\n                      keyGenerator:\n                        editorActor.getSnapshot().context.keyGenerator,\n                      schema: editorActor.getSnapshot().context.schema,\n                    },\n                    blocks: result.insert,\n                    options: {\n                      refreshKeys: true,\n                    },\n                  }),\n                  placement: 'auto',\n                },\n                editor: slateEditor,\n              })\n            } else {\n              console.warn(\n                'Your onPaste function returned something unexpected:',\n                result,\n              )\n            }\n          })\n          .catch((error) => {\n            console.warn(error)\n\n            return error\n          })\n          .finally(() => {\n            editorActor.send({type: 'notify.done loading'})\n          })\n      } else if (event.nativeEvent.clipboardData) {\n        // Prevent Slate from handling the event\n        event.preventDefault()\n        event.stopPropagation()\n\n        const selection = editorActor.getSnapshot().context.selection\n        const position = selection ? {selection} : undefined\n\n        if (!position) {\n          console.warn('Could not find position for paste event')\n          return\n        }\n\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'clipboard.paste',\n            originEvent: {\n              dataTransfer: event.nativeEvent.clipboardData,\n            },\n            position,\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n\n      debug('No result from custom paste handler, pasting normally')\n    },\n    [editorActor, onPaste, portableTextEditor, schemaTypes, slateEditor],\n  )\n\n  const handleOnFocus: FocusEventHandler<HTMLDivElement> = useCallback(\n    (event) => {\n      if (onFocus) {\n        onFocus(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        const selection = PortableTextEditor.getSelection(portableTextEditor)\n        // Create an editor selection if it does'nt exist\n        if (selection === null) {\n          Transforms.select(slateEditor, Editor.start(slateEditor, []))\n          slateEditor.onChange()\n        }\n        editorActor.send({type: 'notify.focused', event})\n        const newSelection = PortableTextEditor.getSelection(portableTextEditor)\n        // If the selection is the same, emit it explicitly here as there is no actual onChange event triggered.\n        if (selection === newSelection) {\n          editorActor.send({\n            type: 'notify.selection',\n            selection,\n          })\n        }\n      }\n    },\n    [editorActor, onFocus, portableTextEditor, slateEditor],\n  )\n\n  const handleClick = useCallback(\n    (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n      if (onClick) {\n        onClick(event)\n      }\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        schema: editorActor.getSnapshot().context.schema,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        console.warn('Could not find EventPosition for MouseEvent')\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'mouse.click',\n          position,\n        },\n        editor: slateEditor,\n        nativeEvent: event,\n      })\n    },\n    [onClick, editorActor, slateEditor],\n  )\n\n  const handleOnBlur: FocusEventHandler<HTMLDivElement> = useCallback(\n    (event) => {\n      if (onBlur) {\n        onBlur(event)\n      }\n      if (!event.isPropagationStopped()) {\n        editorActor.send({type: 'notify.blurred', event})\n      }\n    },\n    [editorActor, onBlur],\n  )\n\n  const handleOnBeforeInput = useCallback(\n    (event: InputEvent) => {\n      if (onBeforeInput) {\n        onBeforeInput(event)\n      }\n    },\n    [onBeforeInput],\n  )\n\n  // This function will handle unexpected DOM changes inside the Editable rendering,\n  // and make sure that we can maintain a stable slateEditor.selection when that happens.\n  //\n  // For example, if this Editable is rendered inside something that might re-render\n  // this component (hidden contexts) while the user is still actively changing the\n  // contentEditable, this could interfere with the intermediate DOM selection,\n  // which again could be picked up by ReactEditor's event listeners.\n  // If that range is invalid at that point, the slate.editorSelection could be\n  // set either wrong, or invalid, to which slateEditor will throw exceptions\n  // that are impossible to recover properly from or result in a wrong selection.\n  //\n  // Also the other way around, when the ReactEditor will try to create a DOM Range\n  // from the current slateEditor.selection, it may throw unrecoverable errors\n  // if the current editor.selection is invalid according to the DOM.\n  // If this is the case, default to selecting the top of the document, if the\n  // user already had a selection.\n  const validateSelection = useCallback(() => {\n    if (!slateEditor.selection) {\n      return\n    }\n    const root = ReactEditor.findDocumentOrShadowRoot(slateEditor)\n    const {activeElement} = root\n    // Return if the editor isn't the active element\n    if (ref.current !== activeElement) {\n      return\n    }\n    const window = ReactEditor.getWindow(slateEditor)\n    const domSelection = window.getSelection()\n    if (!domSelection || domSelection.rangeCount === 0) {\n      return\n    }\n    const existingDOMRange = domSelection.getRangeAt(0)\n    try {\n      const newDOMRange = ReactEditor.toDOMRange(\n        slateEditor,\n        slateEditor.selection,\n      )\n      if (\n        newDOMRange.startOffset !== existingDOMRange.startOffset ||\n        newDOMRange.endOffset !== existingDOMRange.endOffset\n      ) {\n        debug('DOM range out of sync, validating selection')\n        // Remove all ranges temporary\n        domSelection?.removeAllRanges()\n        // Set the correct range\n        domSelection.addRange(newDOMRange)\n      }\n    } catch {\n      debug(`Could not resolve selection, selecting top document`)\n      // Deselect the editor\n      Transforms.deselect(slateEditor)\n      // Select top document if there is a top block to select\n      if (slateEditor.children.length > 0) {\n        Transforms.select(slateEditor, [0, 0])\n      }\n      slateEditor.onChange()\n    }\n  }, [ref, slateEditor])\n\n  // Observe mutations (child list and subtree) to this component's DOM,\n  // and make sure the editor selection is valid when that happens.\n  useEffect(() => {\n    if (editableElement) {\n      const mutationObserver = new MutationObserver(validateSelection)\n      mutationObserver.observe(editableElement, {\n        attributeOldValue: false,\n        attributes: false,\n        characterData: false,\n        childList: true,\n        subtree: true,\n      })\n      return () => {\n        mutationObserver.disconnect()\n      }\n    }\n    return undefined\n  }, [validateSelection, editableElement])\n\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent<HTMLDivElement>) => {\n      if (props.onKeyDown) {\n        props.onKeyDown(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        slateEditor.pteWithHotKeys(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'keyboard.keydown',\n            originEvent: {\n              key: event.key,\n              code: event.code,\n              altKey: event.altKey,\n              ctrlKey: event.ctrlKey,\n              metaKey: event.metaKey,\n              shiftKey: event.shiftKey,\n            },\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [props, editorActor, slateEditor],\n  )\n\n  const handleKeyUp = useCallback(\n    (event: KeyboardEvent<HTMLDivElement>) => {\n      if (props.onKeyUp) {\n        props.onKeyUp(event)\n      }\n      if (!event.isDefaultPrevented()) {\n        editorActor.send({\n          type: 'behavior event',\n          behaviorEvent: {\n            type: 'keyboard.keyup',\n            originEvent: {\n              key: event.key,\n              code: event.code,\n              altKey: event.altKey,\n              ctrlKey: event.ctrlKey,\n              metaKey: event.metaKey,\n              shiftKey: event.shiftKey,\n            },\n          },\n          editor: slateEditor,\n          nativeEvent: event,\n        })\n      }\n    },\n    [props, editorActor, slateEditor],\n  )\n\n  const scrollSelectionIntoViewToSlate = useMemo(() => {\n    // Use slate-react default scroll into view\n    if (scrollSelectionIntoView === undefined) {\n      return undefined\n    }\n    // Disable scroll into view totally\n    if (scrollSelectionIntoView === null) {\n      return noop\n    }\n    // Translate PortableTextEditor prop fn to Slate plugin fn\n    return (_editor: ReactEditor, domRange: Range) => {\n      scrollSelectionIntoView(portableTextEditor, domRange)\n    }\n  }, [portableTextEditor, scrollSelectionIntoView])\n\n  const decorate: (entry: NodeEntry) => BaseRange[] = useCallback(\n    ([, path]) => {\n      if (isEqualToEmptyEditor(slateEditor.children, schemaTypes)) {\n        return [\n          {\n            anchor: {\n              path: [0, 0],\n              offset: 0,\n            },\n            focus: {\n              path: [0, 0],\n              offset: 0,\n            },\n            placeholder: true,\n          },\n        ]\n      }\n      // Editor node has a path length of 0 (should never be decorated)\n      if (path.length === 0) {\n        return []\n      }\n      const result = rangeDecorationState.filter((item) => {\n        // Special case in order to only return one decoration for collapsed ranges\n        if (SlateRange.isCollapsed(item)) {\n          // Collapsed ranges should only be decorated if they are on a block child level (length 2)\n          if (path.length !== 2) {\n            return false\n          }\n          return (\n            Path.equals(item.focus.path, path) &&\n            Path.equals(item.anchor.path, path)\n          )\n        }\n        // Include decorations that either include or intersects with this path\n        return (\n          SlateRange.intersection(item, {\n            anchor: {path, offset: 0},\n            focus: {path, offset: 0},\n          }) || SlateRange.includes(item, path)\n        )\n      })\n      if (result.length > 0) {\n        return result\n      }\n      return []\n    },\n    [slateEditor, schemaTypes, rangeDecorationState],\n  )\n\n  // Set the forwarded ref to be the Slate editable DOM element\n  // Also set the editable element in a state so that the MutationObserver\n  // is setup when this element is ready.\n  useEffect(() => {\n    ref.current = ReactEditor.toDOMNode(\n      slateEditor,\n      slateEditor,\n    ) as HTMLDivElement | null\n    setEditableElement(ref.current)\n  }, [slateEditor, ref])\n\n  useEffect(() => {\n    const window = ReactEditor.getWindow(slateEditor)\n\n    const onDragEnd = () => {\n      editorActor.send({type: 'dragend'})\n    }\n    const onDrop = () => {\n      editorActor.send({type: 'drop'})\n    }\n\n    window.document.addEventListener('dragend', onDragEnd)\n    window.document.addEventListener('drop', onDrop)\n\n    return () => {\n      window.document.removeEventListener('dragend', onDragEnd)\n      window.document.removeEventListener('drop', onDrop)\n    }\n  }, [slateEditor, editorActor])\n\n  const handleDragStart = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragStart?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        schema: editorActor.getSnapshot().context.schema,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        console.warn('Could not find position for dragstart event')\n        return\n      }\n\n      const snapshot = getEditorSnapshot({\n        editorActorSnapshot: editorActor.getSnapshot(),\n        slateEditorInstance: slateEditor,\n      })\n      const dragSelection = getDragSelection({\n        eventSelection: position.selection,\n        snapshot,\n      })\n\n      const selectingEntireBlocks = selectors.isSelectingEntireBlocks({\n        ...snapshot,\n        context: {\n          ...snapshot.context,\n          selection: dragSelection,\n        },\n      })\n\n      const dragGhost = document.createElement('div')\n\n      const draggedDomNodes = getSelectionDomNodes({\n        snapshot: {\n          ...snapshot,\n          context: {\n            ...snapshot.context,\n            selection: dragSelection,\n          },\n        },\n        slateEditor,\n      })\n\n      if (selectingEntireBlocks) {\n        // Clone the DOM Nodes so they won't be visually clipped by scroll-containers etc.\n        const clonedBlockNodes = draggedDomNodes.blockNodes.map((node) =>\n          node.cloneNode(true),\n        )\n\n        for (const block of clonedBlockNodes) {\n          if (block instanceof HTMLElement) {\n            block.style.position = 'relative'\n          }\n          dragGhost.appendChild(block)\n        }\n\n        // A custom drag ghost element can be configured using this data attribute\n        const customGhost = dragGhost.querySelector(\n          '[data-pt-drag-ghost-element]',\n        )\n        if (customGhost) {\n          dragGhost.replaceChildren(customGhost)\n        }\n\n        // Setting the `data-dragged` attribute so the consumer can style the element while it’s dragged\n        dragGhost.setAttribute('data-dragged', '')\n\n        dragGhost.style.position = 'absolute'\n        dragGhost.style.left = '-99999px'\n        dragGhost.style.boxSizing = 'border-box'\n        document.body.appendChild(dragGhost)\n\n        if (customGhost) {\n          const customGhostRect = customGhost.getBoundingClientRect()\n          const x = event.clientX - customGhostRect.left\n          const y = event.clientY - customGhostRect.top\n          dragGhost.style.width = `${customGhostRect.width}px`\n          dragGhost.style.height = `${customGhostRect.height}px`\n          event.dataTransfer.setDragImage(dragGhost, x, y)\n        } else {\n          const blocksDomRect = getCompoundClientRect(\n            draggedDomNodes.blockNodes,\n          )\n          const x = event.clientX - blocksDomRect.left\n          const y = event.clientY - blocksDomRect.top\n          dragGhost.style.width = `${blocksDomRect.width}px`\n          dragGhost.style.height = `${blocksDomRect.height}px`\n          event.dataTransfer.setDragImage(dragGhost, x, y)\n        }\n      } else {\n        const clonedChildNodes = draggedDomNodes.childNodes.map((node) =>\n          node.cloneNode(true),\n        )\n\n        for (const child of clonedChildNodes) {\n          dragGhost.appendChild(child)\n        }\n\n        dragGhost.style.position = 'absolute'\n        dragGhost.style.left = '-99999px'\n        dragGhost.style.boxSizing = 'border-box'\n        document.body.appendChild(dragGhost)\n\n        const childrenDomRect = getCompoundClientRect(\n          draggedDomNodes.childNodes,\n        )\n        const x = event.clientX - childrenDomRect.left\n        const y = event.clientY - childrenDomRect.top\n        dragGhost.style.width = `${childrenDomRect.width}px`\n        dragGhost.style.height = `${childrenDomRect.height}px`\n\n        event.dataTransfer.setDragImage(dragGhost, x, y)\n      }\n\n      // Select drag selection\n      // If the selection is expanded then we just select the end of the\n      // selection\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'select',\n          selection: isSelectionCollapsed(dragSelection)\n            ? dragSelection\n            : {\n                anchor: getSelectionEndPoint(dragSelection),\n                focus: getSelectionEndPoint(dragSelection),\n                backward: false,\n              },\n        },\n        editor: slateEditor,\n      })\n\n      editorActor.send({\n        type: 'dragstart',\n        origin: {\n          selection: dragSelection,\n        },\n        ghost: dragGhost,\n      })\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragstart',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n          position: {\n            selection: dragSelection,\n          },\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragStart, editorActor, slateEditor],\n  )\n\n  const handleDrag = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDrag?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        schema: editorActor.getSnapshot().context.schema,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.drag',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDrag, editorActor, slateEditor],\n  )\n\n  const handleDragEnd = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragEnd?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragend',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragEnd, editorActor, slateEditor],\n  )\n\n  const handleDragEnter = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragEnter?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        schema: editorActor.getSnapshot().context.schema,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragenter',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n          position,\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragEnter, editorActor, slateEditor],\n  )\n\n  const handleDragOver = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragOver?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        schema: editorActor.getSnapshot().context.schema,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragover',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n          position,\n        },\n        editor: slateEditor,\n        nativeEvent: event,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragOver, editorActor, slateEditor],\n  )\n\n  const handleDrop = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDrop?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        schema: editorActor.getSnapshot().context.schema,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        console.warn('Could not find position for drop event')\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.drop',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n          position,\n        },\n        editor: slateEditor,\n        nativeEvent: event,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDrop, editorActor, slateEditor],\n  )\n\n  const handleDragLeave = useCallback(\n    (event: React.DragEvent<HTMLDivElement>) => {\n      onDragLeave?.(event)\n\n      if (event.isDefaultPrevented() || event.isPropagationStopped()) {\n        return\n      }\n\n      const position = getEventPosition({\n        schema: editorActor.getSnapshot().context.schema,\n        slateEditor,\n        event: event.nativeEvent,\n      })\n\n      if (!position) {\n        return\n      }\n\n      editorActor.send({\n        type: 'behavior event',\n        behaviorEvent: {\n          type: 'drag.dragleave',\n          originEvent: {\n            dataTransfer: event.dataTransfer,\n          },\n        },\n        editor: slateEditor,\n      })\n\n      // Prevent Slate from handling the event\n      return true\n    },\n    [onDragLeave, editorActor, slateEditor],\n  )\n\n  if (!portableTextEditor) {\n    return null\n  }\n\n  return hasInvalidValue ? null : (\n    <SlateEditable\n      {...restProps}\n      autoFocus={false}\n      className={restProps.className || 'pt-editable'}\n      decorate={decorate}\n      onBlur={handleOnBlur}\n      onCopy={handleCopy}\n      onCut={handleCut}\n      onClick={handleClick}\n      onDOMBeforeInput={handleOnBeforeInput}\n      onDragStart={handleDragStart}\n      onDrag={handleDrag}\n      onDragEnd={handleDragEnd}\n      onDragEnter={handleDragEnter}\n      onDragOver={handleDragOver}\n      onDrop={handleDrop}\n      onDragLeave={handleDragLeave}\n      onFocus={handleOnFocus}\n      onKeyDown={handleKeyDown}\n      onKeyUp={handleKeyUp}\n      onPaste={handlePaste}\n      readOnly={readOnly}\n      // We have implemented our own placeholder logic with decorations.\n      // This 'renderPlaceholder' should not be used.\n      renderPlaceholder={undefined}\n      renderElement={renderElement}\n      renderLeaf={renderLeaf}\n      scrollSelectionIntoView={scrollSelectionIntoViewToSlate}\n    />\n  )\n})\n\nPortableTextEditable.displayName = 'ForwardRef(PortableTextEditable)'\n","import {useEffect} from 'react'\nimport {useEffectEvent} from 'use-effect-event'\nimport type {EditorEmittedEvent} from './editor/editor-machine'\nimport {useEditor} from './editor/editor-provider'\n\n/**\n * @public\n * @deprecated\n * This component has been renamed. Use `EventListenerPlugin` instead.\n *\n * ```\n * import {EventListenerPlugin} from '@portabletext/editor/plugins'\n * ```\n */\nexport function EditorEventListener(props: {\n  on: (event: EditorEmittedEvent) => void\n}) {\n  const editor = useEditor()\n  const on = useEffectEvent(props.on)\n\n  useEffect(() => {\n    const subscription = editor.on('*', on)\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [editor])\n\n  return null\n}\n"],"names":["getCompoundClientRect","nodes","length","DOMRect","elements","filter","node","Element","firstRect","at","getBoundingClientRect","left","top","right","bottom","i","rect","Math","min","max","getDragSelection","eventSelection","snapshot","dragSelection","selectors","context","selection","draggingCollapsedSelection","draggedTextBlock","draggedSpan","anchor","utils","focus","selectedBlocks","selectionStartBlock","selectionEndBlock","selectionStartPoint","selectionEndPoint","getEventPosition","schema","slateEditor","event","getEventNode","block","getNodeBlock","editor","positionBlock","getEventPositionBlock","getEventSelection","Editor","isEditor","path","_key","focusBlockPath","focusBlockKey","undefined","DOMEditor","hasTarget","target","toSlateNode","firstBlock","getFirstBlock","firstBlockRect","toDOMNode","pageY","lastBlock","getLastBlock","lastBlockRef","elementRect","height","abs","range","getSlateRangeFromEvent","toPortableTextRange","fromSlateValue","children","name","isDOMNode","window","getWindow","domRange","document","caretPositionFromPoint","position","clientX","clientY","createRange","setStart","offsetNode","offset","setEnd","caretRangeFromPoint","console","warn","toSlateRange","exactMatch","suppressThrow","normalizePoint","point","value","newPath","newOffset","blockKey","childKey","find","blk","push","Array","isArray","child","cld","text","normalizeSelection","newAnchor","newFocus","isEqual","backward","getSelectionDomNodes","blockNodes","childNodes","blockEntries","from","mode","match","n","childEntries","isTextSpan","isBlock","map","blockNode","childNode","DefaultBlockObject","props","$","_c","t0","Symbol","for","userSelect","t1","_type","DefaultInlineObject","DropIndicator","width","borderBottom","zIndex","debugWithName","EMPTY_ANNOTATIONS","inlineBlockStyle","display","attributes","element","schemaTypes","readOnly","renderBlock","renderChild","renderListItem","renderStyle","spellCheck","editorActor","useContext","EditorActorContext","useSlateStatic","selected","useSelected","blockRef","useRef","inlineBlockObjectRef","focused","Range","isCollapsed","dragPositionBlock","setDragPositionBlock","useState","useEffect","behavior","defineBehavior","on","guard","dropFocusBlock","dragOrigin","beta","internalDrag","origin","some","draggedBlock","actions","type","effect","send","useMemo","KEY_TO_VALUE_ELEMENT","get","renderedBlock","className","blockPath","Error","isInline","ReactEditor","findPath","depth","schemaType","inlineObjects","SlateElement","isElement","elmPath","debugRenders","annotations","editorElementRef","isListItem","style","blockStyleType","styles","item","level","listItem","isListBlock","listType","lists","renderProps","Object","defineProperty","enumerable","propsOrDefaultRendered","blockObjects","renderedBlockFromProps","_props","displayName","debug","EMPTY_MARKS","Leaf","leaf","renderDecorator","renderAnnotation","spanRef","portableTextEditor","usePortableTextEditor","blockSelected","setFocused","setSelected","parent","decoratorValues","decorators","dec","marks","uniq","mark","includes","annotationMarks","markDefs","def","Boolean","shouldTrackSelectionAndFocus","sel","PortableTextEditor","getSelection","isCollapsedSelection","startTransition","setSelectedFromRange","useCallback","winSelection","rangeCount","getRangeAt","current","intersectsNode","onBlur","onFocus","onSelection","unsubscribe","content","returnedChildren","Text","isText","span","forEach","annotation","t","_child","createWithHotkeys","hotkeysFromOptions","reservedHotkeys","activeHotkeys","pteWithHotKeys","keys","cat","hotkey","isHotkey","nativeEvent","preventDefault","possibleMark","behaviorEvent","decorator","possibleCommand","command","withSyncRangeDecorations","syncRangeDecorations","originalApply","apply","op","getSnapshot","matches","PLACEHOLDER_STYLE","pointerEvents","PortableTextEditable","forwardRef","forwardedRef","hotkeys","onBeforeInput","onPaste","onCopy","onCut","onClick","onDragStart","onDrag","onDragEnd","onDragEnter","onDragOver","onDrop","onDragLeave","rangeDecorations","renderPlaceholder","propsSelection","scrollSelectionIntoView","restProps","ref","editableElement","setEditableElement","hasInvalidValue","setHasInvalidValue","rangeDecorationState","setRangeDecorationsState","rangeDecorationsRef","useSelector","s","useSlate","blockTypeName","withHotKeys","renderElement","eProps","renderLeaf","lProps","rendered","placeholder","decoration","rangeDecoration","component","restoreSelectionFromProps","JSON","stringify","normalizedSelection","slateRange","Transforms","select","operations","o","onChange","operation","newSlateRanges","rangeDecorationItem","SlateRange","isRange","onMoved","newSelection","newRange","moveRangeByOperation","getValue","newRangeSelection","onReady","onInvalidValue","onValueChanged","syncedRangeDecorations","setSyncedRangeDecorations","teardown","handleCopy","clipboardData","stopPropagation","originEvent","dataTransfer","handleCut","handlePaste","onPasteResult","Promise","resolve","then","result","insert","blocks","parseBlocks","keyGenerator","options","refreshKeys","placement","catch","error","finally","handleOnFocus","isDefaultPrevented","start","handleClick","isPropagationStopped","handleOnBlur","handleOnBeforeInput","validateSelection","root","findDocumentOrShadowRoot","activeElement","domSelection","existingDOMRange","newDOMRange","toDOMRange","startOffset","endOffset","removeAllRanges","addRange","deselect","mutationObserver","MutationObserver","observe","attributeOldValue","characterData","childList","subtree","disconnect","handleKeyDown","onKeyDown","key","code","altKey","ctrlKey","metaKey","shiftKey","handleKeyUp","onKeyUp","scrollSelectionIntoViewToSlate","noop","_editor","decorate","isEqualToEmptyEditor","Path","equals","intersection","addEventListener","removeEventListener","handleDragStart","getEditorSnapshot","editorActorSnapshot","slateEditorInstance","selectingEntireBlocks","dragGhost","createElement","draggedDomNodes","clonedBlockNodes","cloneNode","HTMLElement","appendChild","customGhost","querySelector","replaceChildren","setAttribute","boxSizing","body","customGhostRect","x","y","setDragImage","blocksDomRect","clonedChildNodes","childrenDomRect","isSelectionCollapsed","getSelectionEndPoint","ghost","handleDrag","handleDragEnd","handleDragEnter","handleDragOver","handleDrop","handleDragLeave","SlateEditable","EditorEventListener","useEditor","useEffectEvent","subscription"],"mappings":"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"}