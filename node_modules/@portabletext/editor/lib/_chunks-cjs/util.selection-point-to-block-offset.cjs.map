{"version":3,"file":"util.selection-point-to-block-offset.cjs","sources":["../../src/utils/util.block-offset-to-block-selection-point.ts","../../src/utils/util.block-offset-to-selection-point.ts","../../src/utils/util.block-offsets-to-selection.ts","../../src/utils/util.child-selection-point-to-block-offset.ts","../../src/internal-utils/asserters.ts","../../src/internal-utils/parse-blocks.ts","../../src/utils/util.selection-point-to-block-offset.ts"],"sourcesContent":["import type {PortableTextBlock} from '@sanity/types'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport function blockOffsetToBlockSelectionPoint({\n  value,\n  blockOffset,\n}: {\n  value: Array<PortableTextBlock>\n  blockOffset: BlockOffset\n}): EditorSelectionPoint | undefined {\n  let selectionPoint: EditorSelectionPoint | undefined\n\n  for (const block of value) {\n    if (block._key === blockOffset.path[0]._key) {\n      selectionPoint = {\n        path: [{_key: block._key}],\n        offset: blockOffset.offset,\n      }\n      break\n    }\n  }\n\n  return selectionPoint\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {blockOffsetToSpanSelectionPoint} from './util.block-offset'\nimport {blockOffsetToBlockSelectionPoint} from './util.block-offset-to-block-selection-point'\n\n/**\n * @public\n */\nexport function blockOffsetToSelectionPoint({\n  value,\n  blockOffset,\n  direction,\n}: {\n  value: Array<PortableTextBlock>\n  blockOffset: BlockOffset\n  direction: 'forward' | 'backward'\n}): EditorSelectionPoint | undefined {\n  const spanSelectionPoint = blockOffsetToSpanSelectionPoint({\n    value,\n    blockOffset,\n    direction,\n  })\n\n  if (!spanSelectionPoint) {\n    return blockOffsetToBlockSelectionPoint({\n      value,\n      blockOffset,\n    })\n  }\n\n  return spanSelectionPoint\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelection} from '..'\nimport type {BlockOffset} from '../types/block-offset'\nimport {blockOffsetToSelectionPoint} from './util.block-offset-to-selection-point'\n\n/**\n * @public\n */\nexport function blockOffsetsToSelection({\n  value,\n  offsets,\n  backward,\n}: {\n  value: Array<PortableTextBlock>\n  offsets: {anchor: BlockOffset; focus: BlockOffset}\n  backward?: boolean\n}): EditorSelection {\n  const anchor = blockOffsetToSelectionPoint({\n    value,\n    blockOffset: offsets.anchor,\n    direction: backward ? 'backward' : 'forward',\n  })\n  const focus = blockOffsetToSelectionPoint({\n    value,\n    blockOffset: offsets.focus,\n    direction: backward ? 'forward' : 'backward',\n  })\n\n  if (!anchor || !focus) {\n    return null\n  }\n\n  return {\n    anchor,\n    focus,\n    backward,\n  }\n}\n","import {\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type PortableTextBlock,\n} from '@sanity/types'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {isKeyedSegment} from './util.is-keyed-segment'\n\n/**\n * @public\n */\nexport function childSelectionPointToBlockOffset({\n  value,\n  selectionPoint,\n}: {\n  value: Array<PortableTextBlock>\n  selectionPoint: EditorSelectionPoint\n}): BlockOffset | undefined {\n  let offset = 0\n\n  const blockKey = isKeyedSegment(selectionPoint.path[0])\n    ? selectionPoint.path[0]._key\n    : undefined\n  const childKey = isKeyedSegment(selectionPoint.path[2])\n    ? selectionPoint.path[2]._key\n    : undefined\n\n  if (!blockKey || !childKey) {\n    return undefined\n  }\n\n  for (const block of value) {\n    if (block._key !== blockKey) {\n      continue\n    }\n\n    if (!isPortableTextTextBlock(block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (child._key === childKey) {\n        return {\n          path: [{_key: block._key}],\n          offset: offset + selectionPoint.offset,\n        }\n      }\n\n      if (isPortableTextSpan(child)) {\n        offset += child.text.length\n      }\n    }\n  }\n}\n","import type {TypedObject} from '@sanity/types'\n\nexport function isTypedObject(object: unknown): object is TypedObject {\n  return isRecord(object) && typeof object._type === 'string'\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value === 'object' || typeof value === 'function')\n}\n","import type {\n  PortableTextBlock,\n  PortableTextObject,\n  PortableTextSpan,\n  PortableTextTextBlock,\n} from '@sanity/types'\nimport type {EditorSchema} from '../editor/define-schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {isTypedObject} from './asserters'\n\nexport function parseBlocks({\n  context,\n  blocks,\n  options,\n}: {\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  blocks: unknown\n  options: {\n    refreshKeys: boolean\n  }\n}): Array<PortableTextBlock> {\n  if (!Array.isArray(blocks)) {\n    return []\n  }\n\n  return blocks.flatMap((block) => {\n    const parsedBlock = parseBlock({context, block, options})\n\n    return parsedBlock ? [parsedBlock] : []\n  })\n}\n\nexport function parseBlock({\n  context,\n  block,\n  options,\n}: {\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  block: unknown\n  options: {\n    refreshKeys: boolean\n  }\n}): PortableTextBlock | undefined {\n  return (\n    parseTextBlock({block, context, options}) ??\n    parseBlockObject({blockObject: block, context, options})\n  )\n}\n\nfunction parseBlockObject({\n  blockObject,\n  context,\n  options,\n}: {\n  blockObject: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {refreshKeys: boolean}\n}): PortableTextObject | undefined {\n  if (!isTypedObject(blockObject)) {\n    return undefined\n  }\n\n  if (\n    blockObject._type === context.schema.block.name ||\n    blockObject._type === 'block' ||\n    !context.schema.blockObjects.some(({name}) => name === blockObject._type)\n  ) {\n    return undefined\n  }\n\n  return {\n    ...blockObject,\n    _key: options.refreshKeys\n      ? context.keyGenerator()\n      : typeof blockObject._key === 'string'\n        ? blockObject._key\n        : context.keyGenerator(),\n  }\n}\n\nexport function isTextBlock(\n  schema: EditorSchema,\n  block: unknown,\n): block is PortableTextTextBlock {\n  return (\n    parseTextBlock({\n      block,\n      context: {schema, keyGenerator: () => ''},\n      options: {refreshKeys: false},\n    }) !== undefined\n  )\n}\n\nfunction parseTextBlock({\n  block,\n  context,\n  options,\n}: {\n  block: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {refreshKeys: boolean}\n}): PortableTextTextBlock | undefined {\n  if (!isTypedObject(block)) {\n    return undefined\n  }\n\n  if (block._type !== context.schema.block.name) {\n    return undefined\n  }\n\n  const _key = options.refreshKeys\n    ? context.keyGenerator()\n    : typeof block._key === 'string'\n      ? block._key\n      : context.keyGenerator()\n\n  const unparsedMarkDefs: Array<unknown> = Array.isArray(block.markDefs)\n    ? block.markDefs\n    : []\n  const markDefKeyMap = new Map<string, string>()\n  const markDefs = unparsedMarkDefs.flatMap((markDef) => {\n    if (!isTypedObject(markDef)) {\n      return []\n    }\n\n    if (typeof markDef._key !== 'string') {\n      return []\n    }\n\n    if (\n      context.schema.annotations.some(\n        (annotation) => annotation.name === markDef._type,\n      )\n    ) {\n      const _key = options.refreshKeys ? context.keyGenerator() : markDef._key\n      markDefKeyMap.set(markDef._key, _key)\n\n      return [\n        {\n          ...markDef,\n          _key,\n        },\n      ]\n    }\n\n    return []\n  })\n\n  const unparsedChildren: Array<unknown> = Array.isArray(block.children)\n    ? block.children\n    : []\n\n  const children = unparsedChildren\n    .map(\n      (child) =>\n        parseSpan({span: child, context, markDefKeyMap, options}) ??\n        parseInlineObject({inlineObject: child, context, options}),\n    )\n    .filter((child) => child !== undefined)\n\n  const parsedBlock: PortableTextTextBlock = {\n    // Spread the entire block to allow custom properties on it\n    ...block,\n    _key,\n    children:\n      children.length > 0\n        ? children\n        : [\n            {\n              _key: context.keyGenerator(),\n              _type: context.schema.span.name,\n              text: '',\n              marks: [],\n            },\n          ],\n    markDefs,\n  }\n\n  /**\n   * Reset text block .style if it's somehow set to an invalid type\n   */\n  if (\n    typeof parsedBlock.style !== 'string' ||\n    !context.schema.styles.find((style) => style.value === block.style)\n  ) {\n    const defaultStyle = context.schema.styles.at(0)?.value\n\n    if (defaultStyle !== undefined) {\n      parsedBlock.style = defaultStyle\n    } else {\n      delete parsedBlock.style\n    }\n  }\n\n  /**\n   * Reset text block .listItem if it's somehow set to an invalid type\n   */\n  if (\n    typeof parsedBlock.listItem !== 'string' ||\n    !context.schema.lists.find((list) => list.value === block.listItem)\n  ) {\n    delete parsedBlock.listItem\n  }\n\n  /**\n   * Reset text block .level if it's somehow set to an invalid type\n   */\n  if (typeof parsedBlock.level !== 'number') {\n    delete parsedBlock.level\n  }\n\n  return parsedBlock\n}\n\nexport function isSpan(\n  schema: EditorSchema,\n  child: PortableTextSpan | PortableTextObject,\n): child is PortableTextSpan {\n  return (\n    parseSpan({\n      span: child,\n      markDefKeyMap: new Map(),\n      context: {schema, keyGenerator: () => ''},\n      options: {refreshKeys: false},\n    }) !== undefined\n  )\n}\n\nexport function parseSpan({\n  span,\n  context,\n  markDefKeyMap,\n  options,\n}: {\n  span: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  markDefKeyMap: Map<string, string>\n  options: {refreshKeys: boolean}\n}): PortableTextSpan | undefined {\n  if (!isTypedObject(span)) {\n    return undefined\n  }\n\n  // In reality, the span schema name is always 'span', but we only the check here anyway\n  if (span._type !== context.schema.span.name || span._type !== 'span') {\n    return undefined\n  }\n\n  const unparsedMarks: Array<unknown> = Array.isArray(span.marks)\n    ? span.marks\n    : []\n  const marks = unparsedMarks.flatMap((mark) => {\n    if (typeof mark !== 'string') {\n      return []\n    }\n\n    const markDefKey = markDefKeyMap.get(mark)\n\n    if (markDefKey !== undefined) {\n      return [markDefKey]\n    }\n\n    if (\n      context.schema.decorators.some((decorator) => decorator.value === mark)\n    ) {\n      return [mark]\n    }\n\n    return []\n  })\n\n  return {\n    // Spread the entire span to allow custom properties on it\n    ...span,\n    _type: 'span',\n    _key: options.refreshKeys\n      ? context.keyGenerator()\n      : typeof span._key === 'string'\n        ? span._key\n        : context.keyGenerator(),\n    text: typeof span.text === 'string' ? span.text : '',\n    marks,\n  }\n}\n\nfunction parseInlineObject({\n  inlineObject,\n  context,\n  options,\n}: {\n  inlineObject: unknown\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  options: {refreshKeys: boolean}\n}): PortableTextObject | undefined {\n  if (!isTypedObject(inlineObject)) {\n    return undefined\n  }\n\n  if (\n    inlineObject._type === context.schema.span.name ||\n    inlineObject._type === 'span' ||\n    // Respect the schema definition and don't parse inline objects that are not defined\n    !context.schema.inlineObjects.some(({name}) => name === inlineObject._type)\n  ) {\n    return undefined\n  }\n\n  return {\n    // Spread the entire inline object to allow custom properties on it\n    ...inlineObject,\n    _key: options.refreshKeys\n      ? context.keyGenerator()\n      : typeof inlineObject._key === 'string'\n        ? inlineObject._key\n        : context.keyGenerator(),\n  }\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {childSelectionPointToBlockOffset} from './util.child-selection-point-to-block-offset'\nimport {isKeyedSegment} from './util.is-keyed-segment'\n\n/**\n * @public\n */\nexport function selectionPointToBlockOffset({\n  value,\n  selectionPoint,\n}: {\n  value: Array<PortableTextBlock>\n  selectionPoint: EditorSelectionPoint\n}): BlockOffset | undefined {\n  if (\n    selectionPoint.path.length === 1 &&\n    isKeyedSegment(selectionPoint.path[0])\n  ) {\n    return {\n      path: [{_key: selectionPoint.path[0]._key}],\n      offset: selectionPoint.offset,\n    }\n  }\n\n  return childSelectionPointToBlockOffset({\n    value,\n    selectionPoint,\n  })\n}\n"],"names":["blockOffsetToBlockSelectionPoint","value","blockOffset","selectionPoint","block","_key","path","offset","blockOffsetToSelectionPoint","direction","blockOffsetToSpanSelectionPoint","blockOffsetsToSelection","offsets","backward","anchor","focus","childSelectionPointToBlockOffset","blockKey","isKeyedSegment","undefined","childKey","isPortableTextTextBlock","child","children","isPortableTextSpan","text","length","isTypedObject","object","isRecord","_type","parseBlocks","context","blocks","options","Array","isArray","flatMap","parsedBlock","parseBlock","parseTextBlock","parseBlockObject","blockObject","schema","name","blockObjects","some","refreshKeys","keyGenerator","isTextBlock","unparsedMarkDefs","markDefs","markDefKeyMap","Map","markDef","annotations","annotation","set","map","parseSpan","span","parseInlineObject","inlineObject","filter","marks","style","styles","find","defaultStyle","at","listItem","lists","list","level","mark","markDefKey","get","decorators","decorator","inlineObjects","selectionPointToBlockOffset"],"mappings":"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"}