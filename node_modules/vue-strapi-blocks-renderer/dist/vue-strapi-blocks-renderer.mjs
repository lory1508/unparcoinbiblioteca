import { h as n, Comment as p, Fragment as y } from "vue";
const m = "vue-strapi-blocks-renderer", k = ({ componentsContext: e, text: t, ...i }) => {
  const { modifiers: r, missingModifierTypes: o } = e;
  return Object.keys(i).reduce(
    // @ts-ignore
    (c, s) => {
      if (!i[s])
        return c;
      const u = r[s];
      return u ? u({
        // @ts-ignore
        children: c
      }) : (o.includes(s) || (console.warn(
        `[${m}] No component found for modifier "${s}"`
      ), o.push(s)), c);
    },
    // By default, return the text without any wrapper to avoid useless nesting
    t
  );
}, T = ["image"], b = (e) => {
  const { children: t, type: i, ...r } = e;
  if (i === "code") {
    const o = (l) => l.reduce((c, s) => s.type === "text" ? c.concat(s.text) : s.type === "link" ? c.concat(o(s.children)) : c, "");
    return {
      ...r,
      plainText: o(e.children)
    };
  }
  return r;
}, a = ({ content: e, componentsContext: t }) => {
  const { children: i, type: r, ...o } = e, { blocks: l, missingBlockTypes: c } = t, s = l[r];
  if (!s)
    return c.includes(r) || (console.warn(`[${m}] No component found for block type "${r}"`), c.push(r)), null;
  if (T.includes(r))
    return s(o);
  if (r === "paragraph" && i.length === 1 && i[0].type === "text" && i[0].text === "")
    return n("br");
  const u = b(e), h = i.map((d) => {
    if (d.type === "text") {
      const { type: B, ...g } = d;
      return k({ componentsContext: t, ...g });
    }
    return a({ content: d, componentsContext: t });
  });
  return s({ children: h, ...u });
}, f = {
  blocks: {
    paragraph: (e) => n("p", {}, e.children),
    quote: (e) => n("blockquote", {}, e.children),
    code: (e) => n("pre", {}, [n("code", {}, e.plainText)]),
    heading: ({ level: e, children: t }) => {
      switch (e) {
        case 1:
          return n("h1", {}, t);
        case 2:
          return n("h2", {}, t);
        case 3:
          return n("h3", {}, t);
        case 4:
          return n("h4", {}, t);
        case 5:
          return n("h5", {}, t);
        case 6:
          return n("h6", {}, t);
      }
    },
    link: (e) => n("a", { href: e.url }, e.children),
    list: (e) => {
      const t = e.format === "ordered";
      return n(t ? "ol" : "ul", {}, e.children);
    },
    "list-item": (e) => n("li", {}, e.children),
    image: ({ image: e }) => n("img", {
      src: e.url,
      alt: e.alternativeText || void 0
    })
  },
  modifiers: {
    bold: (e) => n("strong", {}, e.children),
    italic: (e) => n("em", {}, e.children),
    underline: (e) => n("u", {}, e.children),
    strikethrough: (e) => n("del", {}, e.children),
    code: (e) => n("code", {}, e.children)
  },
  missingBlockTypes: [],
  missingModifierTypes: []
}, M = (e) => {
  const t = {
    ...f.blocks,
    ...e.blocks
  }, i = {
    ...f.modifiers,
    ...e.modifiers
  }, r = {
    blocks: t,
    modifiers: i,
    missingBlockTypes: [],
    missingModifierTypes: []
  };
  if (!e.content)
    throw new Error("BlocksRenderer content is empty");
  const o = e.content.map(
    (l) => a({ content: l, componentsContext: r })
  );
  return r.missingBlockTypes.length && o.unshift(
    n(p, `missingBlockTypes: ${r.missingBlockTypes}`)
  ), r.missingModifierTypes.length && o.unshift(
    n(
      p,
      `missingModifierTypes: ${r.missingModifierTypes}`
    )
  ), n(y, o);
};
export {
  M as StrapiBlocks
};
